# /usr/bin/pythonimport numpy as npimport copy, os, sysfrom PIL import Imageimport mathimport matplotlib.cm as cmimport matplotlib.pyplot as pltfrom scipy.optimize import curve_fit### Inputs ###calib_file = 'CeO2_Pil207_E30_2Nov2016_001.imctrl'diff_file = 'CeO2_Pil207_E30_2Nov2016_001.tif'pix = 17.2 #microns# GUI needed to set inputs? ##### Functions ##def load_inputs_file(filenam):    '''    Parse inputs file, create type specific inputs.    '''    filelines = parms_file.readlines()    parms_dict = {}    for item in filelines:        newparms = item.strip('\n').split(':',1)        parm = newparms[1]        value = None        # print parm        try:             value = int(parm)            parms_dict[str(newparms[0])] = value        except ValueError:            try:                value = float(parm)                parms_dict[newparms[0]] = value            except ValueError:                if parm.startswith('['):                    listvals = parm.strip('[').strip(']').split(',')                    newlist = []                    for val in listvals:                        newValue = None                        try:                             newValue = int(val)                            newlist.append(newValue)                        except ValueError:                            try:                                newValue = float(val)                                newlist.append(newValue)                            except ValueError:                                newlist.append(val.replace("'","").replace(" ",""))                    parms_dict[newparms[0]] = newlist                elif parm.startswith('{'):                    # print parm                    listvals = parm.strip('{').strip('}').split(',')                    newdict = {}                    for keyval in listvals:                        # print keyval                        newkey = keyval.split(':')[0].replace("'","").replace(" ","")                        val = keyval.split(':')[1]                        newValue = None                        try:                             newValue = int(val)                            newdict[str(newkey)] = newValue                        except ValueError:                            try:                                newValue = float(val)                                newdict[str(newkey)] = newValue                            except ValueError:                                newdict[str(newkey)] = val.replace("'","").replace(" ","")                    parms_dict[newparms[0]] = newdict                elif not parm:                    parms_dict[newparms[0]] = ''                                    else:                    parms_dict[newparms[0]] = str(parm)    return parms_dict    ## Functions below taken from GSAS-II code see https://github.com/svaksha/pyGSAS/ ## Toby, B. H., & Von Dreele, R. B. (2013). "GSAS-II: the genesis of a modern open-source ## all purpose crystallography software package". Journal of Applied Crystallography, ## 46(2), 544-549. ###trig functionssind = lambda x: math.sin(x*math.pi/180.)asind = lambda x: 180.*math.asin(x)/math.pitand = lambda x: math.tan(x*math.pi/180.)atand = lambda x: 180.*math.atan(x)/math.piatan2d = lambda y,x: 180.*math.atan2(y,x)/math.picosd = lambda x: math.cos(x*math.pi/180.)acosd = lambda x: 180.*math.acos(x)/math.pirdsq2d = lambda x,p: round(1.0/math.sqrt(x),p)#numpy trig functionsnpsind = lambda x: np.sin(x*np.pi/180.)npasind = lambda x: 180.*np.arcsin(x)/np.pinpcosd = lambda x: np.cos(x*np.pi/180.)npacosd = lambda x: 180.*np.arccos(x)/np.pinptand = lambda x: np.tan(x*np.pi/180.)npatand = lambda x: 180.*np.arctan(x)/np.pinpatan2d = lambda y,x: 180.*np.arctan2(y,x)/np.pidef makeMat(Angle,Axis):    '''Make rotation matrix from Angle and Axis    :param float Angle: in degrees    :param int Axis: 0 for rotation about x, 1 for about y, etc.    '''    cs = npcosd(Angle)    ss = npsind(Angle)    M = np.array(([1.,0.,0.],[0.,cs,-ss],[0.,ss,cs]),dtype=np.float32)    return np.roll(np.roll(M,Axis,axis=0),Axis,axis=1)def peneCorr(tth,dep,tilt=0.,azm=0.):    'Needs a doc string'    return dep*(1.-npcosd(tth))         #best onedef GetTthAzmDsp(x,y,data): #expensive    '''    '''    wave = data['wavelength']    cent = data['center']    tilt = data['tilt']    # print tilt, cosd(tilt)    dist = data['distance']/cosd(tilt)    x0 = data['distance']*tand(tilt)    phi = data['rotation']    dep = data['DetDepth']    LRazim = data['LRazimuth']    azmthoff = data['azmthOff']    dx = np.array(x-cent[0],dtype=np.float32)    dy = np.array(y-cent[1],dtype=np.float32)    D = ((dx-x0)**2+dy**2+data['distance']**2)      #sample to pixel distance    X = np.array(([dx,dy,np.zeros_like(dx)]),dtype=np.float32).T    print np.array(([dx,dy,np.zeros_like(dx)]),dtype=np.float32).shape    X = np.dot(X,makeMat(phi,2))    Z = np.dot(X,makeMat(tilt,0)).T[2]    tth = npatand(np.sqrt(dx**2+dy**2-Z**2)/(dist-Z))    dxy = peneCorr(tth,dep,tilt,npatan2d(dy,dx))    DX = dist-Z+dxy    DY = np.sqrt(dx**2+dy**2-Z**2)    tth = npatan2d(DY,DX)     dsp = wave/(2.*npsind(tth/2.))    azm = (npatan2d(dy,dx)+azmthoff+720.)%360.    G = D/data['distance']**2       #for geometric correction = 1/cos(2theta)^2 if tilt=0.    return np.array([tth,azm,G,dsp])#related calls#def GetTth(x,y,data):    'Give 2-theta value for detector x,y position; calibration info in data'    return GetTthAzmDsp(x,y,data)[0]    def GetTthAzm(x,y,data):    'Give 2-theta, azimuth values for detector x,y position; calibration info in data'    return GetTthAzmDsp(x,y,data)[0:2]def GetDsp(x,y,data):    'Give d-spacing value for detector x,y position; calibration info in data'    return GetTthAzmDsp(x,y,data)[3]       def GetAzm(x,y,data):    'Give azimuth value for detector x,y position; calibration info in data'    return GetTthAzmDsp(x,y,data)[1]#### Main code ###### Load files ### calibration parameter file # parms_file = open(calib_file,'rb')parms_dict = load_inputs_file(parms_file)#print parms_dict## may be a mask file?# diffraction pattern #im = Image.open(diff_file) ##always tiff?#im.show()imarray = np.array(im) print imarray.shape## Convert data ###The bits of the calibration that we need to convert X,Y to 2theta, azimuth or d,azimuth  are: Wavelength (Angstroms), distance (mm), center (X,Y, mm), tilt (degrees), rotation (degrees) and DetDepth (called penetration in screen shot).x = np.arange(imarray.shape[1])y = np.arange(imarray.shape[0])[0:imarray.shape[1]]twotheta = GetTth(x,y,parms_dict)azimu =  GetAzm(x,y,parms_dict)dspace = GetDsp(x,y,parms_dict)#twotheta function of X only? #chi function of Y only?# need to convert imarray (X,Y) into appropriate intensity array for fittingintens = imarray#checks#print twotheta.shape,azimu.shape,dspace.shape,twotheta[0]colors = ("red", "green", "blue") '''bigTwotheta = np.repeat(np.array(twotheta),azimu.shape[0],axis=0)bigAzimu = np.repeat(np.array(azimu),twotheta.shape[0],axis=0)#print bigAzimu.shapemeshX, meshY = np.meshgrid(bigTwotheta,bigAzimu)intens = imarray.flatten()plt.pcolormesh(meshX,meshY,intens)'''plt.scatter(bigTwotheta, bigAzimu, s=1, c=colors, alpha=0.5)#plt.imshow(imarray,origin="lower",cmap=plt.cm.gray_r)plt.show()## Specify ranges to search/starting parameters ###Input from GUI/file?#Load plot to screen and choose regions to fit?#can then slice arrays and calcualte intial guesses from peaks and avgs.h_init = 1w_init = 1d0_init = 1#etc## Setup/Choose function to fit ### start with gaussiandef gauss_full(twotheta,azimu,dspace,h_init,w_init,d0_init):#,):    d = d_0 + a1*np.cos(azimu) + b1*np.sin(azimu) + a2*np.cos(azimu) + b2*np.sin(azimu)   ### limit to n=2    H = H_0 + c1*np.cos(azimu) + d1*np.sin(azimu) + c2*np.cos(azimu) + d2*np.sin(azimu)   ### should include option for n=?    W = W_0 + e1*np.cos(azimu) + f1*np.sin(azimu) + e2*np.cos(azimu) + f2*np.sin(azimu)   ### should include option for n=?    Int = H*exp((-(d-d_x)**2)/2*w**2) + b_g    return Int# need to find parms d_0,a1,a2,b1,b2,H_0,c1,c2,d1,d2,W_0,e1,e2,f1,f2popt,pcurv = curve_fit(gauss_full,azimu,intens,p0=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1])### The above fitting function is the basic curve_fit version used for doing simple 1D Gaussian fits (which you've probably seen) and will likely not work well in this form (for a start it's better in log space), but should hopefully illustrate the glaring holes in my understanding of how to actually apply this to the data arrays. So please hack and return!### As far as my understanding of the functions taken form GSAS-II they essentially take the 2D intensity array and work out the 2_theta and chi for every X,Y pixel. What I'm not quite sure about is that for a nxn input intensity array, it's returning a 2_theta and chi array each of size n. I'm assuming therefore that essentially the 2_theta values are the same for all chi and vice-versa. Is that correct?# I also had to limit the input array to be square i.e. nxn not nxm, is that normal?