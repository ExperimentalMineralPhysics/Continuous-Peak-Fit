# /usr/bin/pythonimport numpy as npimport copy, os, sysfrom PIL import Imageimport mathimport matplotlib.cm as cmimport matplotlib.pyplot as pltfrom scipy.optimize import curve_fit### Inputs ###calib_file = 'CeO2_Pil207_E30_2Nov2016_001.imctrl'diff_file = 'CeO2_Pil207_E30_2Nov2016_001.tif'pix = 172 #microns ##SAH: edit 172 microns not 17.2# GUI needed to set inputs? #### SAH: A GUI would be good for the initial inputs -- most geoscientist types find it is easier to select areas with a mouse than the keyboard.# SAH: The GUI should save an output file that is then used as the input file for batch processing lots of files. ## Functions ##def load_inputs_file(filenam):    '''    Parse inputs file, create type specific inputs.    '''    filelines = parms_file.readlines()    parms_dict = {}    for item in filelines:        newparms = item.strip('\n').split(':',1)        parm = newparms[1]        value = None        # print parm        try:             value = int(parm)            parms_dict[str(newparms[0])] = value        except ValueError:            try:                value = float(parm)                parms_dict[newparms[0]] = value            except ValueError:                if parm.startswith('['):                    listvals = parm.strip('[').strip(']').split(',')                    newlist = []                    for val in listvals:                        newValue = None                        try:                             newValue = int(val)                            newlist.append(newValue)                        except ValueError:                            try:                                newValue = float(val)                                newlist.append(newValue)                            except ValueError:                                newlist.append(val.replace("'","").replace(" ",""))                    parms_dict[newparms[0]] = newlist                elif parm.startswith('{'):                    # print parm                    listvals = parm.strip('{').strip('}').split(',')                    newdict = {}                    for keyval in listvals:                        # print keyval                        newkey = keyval.split(':')[0].replace("'","").replace(" ","")                        val = keyval.split(':')[1]                        newValue = None                        try:                             newValue = int(val)                            newdict[str(newkey)] = newValue                        except ValueError:                            try:                                newValue = float(val)                                newdict[str(newkey)] = newValue                            except ValueError:                                newdict[str(newkey)] = val.replace("'","").replace(" ","")                    parms_dict[newparms[0]] = newdict                elif not parm:                    parms_dict[newparms[0]] = ''                                    else:                    parms_dict[newparms[0]] = str(parm)    return parms_dict    ## Functions below taken from GSAS-II code see https://github.com/svaksha/pyGSAS/ ## Toby, B. H., & Von Dreele, R. B. (2013). "GSAS-II: the genesis of a modern open-source ## all purpose crystallography software package". Journal of Applied Crystallography, ## 46(2), 544-549. ###trig functionssind = lambda x: math.sin(x*math.pi/180.)asind = lambda x: 180.*math.asin(x)/math.pitand = lambda x: math.tan(x*math.pi/180.)atand = lambda x: 180.*math.atan(x)/math.piatan2d = lambda y,x: 180.*math.atan2(y,x)/math.picosd = lambda x: math.cos(x*math.pi/180.)acosd = lambda x: 180.*math.acos(x)/math.pirdsq2d = lambda x,p: round(1.0/math.sqrt(x),p)#numpy trig functionsnpsind = lambda x: np.sin(x*np.pi/180.)npasind = lambda x: 180.*np.arcsin(x)/np.pinpcosd = lambda x: np.cos(x*np.pi/180.)npacosd = lambda x: 180.*np.arccos(x)/np.pinptand = lambda x: np.tan(x*np.pi/180.)npatand = lambda x: 180.*np.arctan(x)/np.pinpatan2d = lambda y,x: 180.*np.arctan2(y,x)/np.pidef makeMat(Angle,Axis):    '''Make rotation matrix from Angle and Axis    :param float Angle: in degrees    :param int Axis: 0 for rotation about x, 1 for about y, etc.    '''    cs = npcosd(Angle)    ss = npsind(Angle)    M = np.array(([1.,0.,0.],[0.,cs,-ss],[0.,ss,cs]),dtype=np.float32)    return np.roll(np.roll(M,Axis,axis=0),Axis,axis=1)def peneCorr(tth,dep,tilt=0.,azm=0.):    'Needs a doc string'    return dep*(1.-npcosd(tth))         #best onedef GetTthAzmDsp(x,y,data): #expensive	## SAH: lifted from: https://subversion.xray.aps.anl.gov/pyGSAS/trunk/GSASIIimage.py    '''    '''    wave = data['wavelength']    cent = data['center']    tilt = data['tilt']    # print tilt, cosd(tilt)    dist = data['distance']/cosd(tilt)    x0 = data['distance']*tand(tilt)    phi = data['rotation']    dep = data['DetDepth']    LRazim = data['LRazimuth']    azmthoff = data['azmthOff']    dx = np.array(x-cent[0],dtype=np.float32)    dy = np.array(y-cent[1],dtype=np.float32)    D = ((dx-x0)**2+dy**2+data['distance']**2)      #sample to pixel distance    X = np.array(([dx,dy,np.zeros_like(dx)]),dtype=np.float32).T    print np.array(([dx,dy,np.zeros_like(dx)]),dtype=np.float32).shape    X = np.dot(X,makeMat(phi,2))    Z = np.dot(X,makeMat(tilt,0)).T[2]    tth = npatand(np.sqrt(dx**2+dy**2-Z**2)/(dist-Z))    dxy = peneCorr(tth,dep,tilt,npatan2d(dy,dx))    DX = dist-Z+dxy    DY = np.sqrt(dx**2+dy**2-Z**2)    tth = npatan2d(DY,DX)     dsp = wave/(2.*npsind(tth/2.))    azm = (npatan2d(dy,dx)+azmthoff+720.)%360.    G = D/data['distance']**2       #for geometric correction = 1/cos(2theta)^2 if tilt=0.    return np.array([tth,azm,G,dsp])#related calls#def GetTth(x,y,data):    'Give 2-theta value for detector x,y position; calibration info in data'    return GetTthAzmDsp(x,y,data)[0]    def GetTthAzm(x,y,data):    'Give 2-theta, azimuth values for detector x,y position; calibration info in data'    return GetTthAzmDsp(x,y,data)[0:2]def GetDsp(x,y,data):    'Give d-spacing value for detector x,y position; calibration info in data'    return GetTthAzmDsp(x,y,data)[3]       def GetAzm(x,y,data):    'Give azimuth value for detector x,y position; calibration info in data'    return GetTthAzmDsp(x,y,data)[1]#### Main code ###### Load files ### calibration parameter file # parms_file = open(calib_file,'rb')parms_dict = load_inputs_file(parms_file)print parms_dict## may be a mask file?## SAH: yes mask files -- they will either be a list of regions (x,y) or a binary image. ## SAH: I will generate you a mask file and send it to you.# diffraction pattern #im = Image.open(diff_file) ##always tiff? ## SAH: No. could be propreity formats. Possible formats for GSAS-II diffracion import are: tif, ADSC, cbf, png, edf, ge, hdf5, mar, rigaku, sfrm, 'gsas-ii image file' and guess.## SAH: GSAS-II import files are located at https://subversion.xray.aps.anl.gov/pyGSAS/trunk/imports/ with the file names 'G2img_*.py'.#im.show()imarray = np.array(im) print imarray.shape## Convert data ###The bits of the calibration that we need to convert X,Y to 2theta, azimuth or d,azimuth  are: Wavelength (Angstroms), distance (mm), center (X,Y, mm), tilt (degrees), rotation (degrees) and DetDepth (called penetration in screen shot).#x = np.arange(imarray.shape[1])#y = np.arange(imarray.shape[0])[0:imarray.shape[1]]gd = np.mgrid[0:imarray.shape[0],0:imarray.shape[1]]       ##SAH: edity = gd[0,:,:]       ##SAH: editx = gd[1,:,:]       ##SAH: edity = y * pix / 1e3   ##SAH: editx = x * pix / 1e3   ##SAH: edit#print x             ##SAH: edit#print y             ##SAH: edit## SAH: would linspace+meshgrid be a better way of making the arrays?#x = np.linspace(0, 1, nx)#y = np.linspace(0, 1, ny)#xv, yv = np.meshgrid(x, y)twotheta = GetTth(x,y,parms_dict)azimu =  GetAzm(x,y,parms_dict)dspace = GetDsp(x,y,parms_dict)#twotheta function of X only? ## SAH: no. both (except in special cases)#chi function of Y only?      ## SAH: no. both (except in special cases)# need to convert imarray (X,Y) into appropriate intensity array for fittingintens = imarrayprint intens#checks#print twotheta.shape,azimu.shape,dspace.shape,twotheta[0]colors = ("red", "green", "blue") '''bigTwotheta = np.repeat(np.array(twotheta),azimu.shape[0],axis=0)bigAzimu = np.repeat(np.array(azimu),twotheta.shape[0],axis=0)#print bigAzimu.shapemeshX, meshY = np.meshgrid(bigTwotheta,bigAzimu)intens = imarray.flatten()plt.pcolormesh(meshX,meshY,intens)'''#plt.scatter(twotheta, azimu, s=1, c=colors, alpha=0.5)      ##SAH: editplt.scatter(twotheta, azimu, s=1, c=np.log(intens), edgecolors='none', cmap='viridis')      ##SAH: edit#plt.gray()plt.colorbar()#plt.scatter(bigTwotheta, bigAzimu, s=1, c=colors, alpha=0.5)#plt.imshow(imarray,origin="lower",cmap=plt.cm.gray_r)plt.show()## Specify ranges to search/starting parameters ###Input from GUI/file? ## SAH: both. I think I would have two functions. ## SAH: A GUI setup function and a wrapper that calls this function with a parameter file or if it does not exist then calls the GUI function.#Load plot to screen and choose regions to fit? ## SAH: yes.#can then slice arrays and calcualte intial guesses from peaks and avgs.h_init = 1w_init = 1d0_init = 1#etc## Setup/Choose function to fit ### start with gaussiandef gauss_full(twotheta,azimu,dspace,h_init,w_init,d0_init):#,):    d = d_0 + a1*np.cos(azimu) + b1*np.sin(azimu) + a2*np.cos(azimu) + b2*np.sin(azimu)   ### limit to n=2    H = H_0 + c1*np.cos(azimu) + d1*np.sin(azimu) + c2*np.cos(azimu) + d2*np.sin(azimu)   ### should include option for n=?    W = W_0 + e1*np.cos(azimu) + f1*np.sin(azimu) + e2*np.cos(azimu) + f2*np.sin(azimu)   ### should include option for n=?    Int = H*exp((-(d-d_x)**2)/2*w**2) + b_g    return Int# need to find parms d_0,a1,a2,b1,b2,H_0,c1,c2,d1,d2,W_0,e1,e2,f1,f2popt,pcurv = curve_fit(gauss_full,azimu,intens,p0=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1])### The above fitting function is the basic curve_fit version used for doing simple 1D Gaussian fits (which you've probably seen) and will likely not work well in this form (for a start it's better in log space), but should hopefully illustrate the glaring holes in my understanding of how to actually apply this to the data arrays. So please hack and return!### As far as my understanding of the functions taken form GSAS-II they essentially take the 2D intensity array and work out the 2_theta and chi for every X,Y pixel. What I'm not quite sure about is that for a nxn input intensity array, it's returning a 2_theta and chi array each of size n.## SAH: you are getting a single n sized array back becuase you are feeding it a single n sized array of y and x. I think that we should be feeding it an array of the x value for each pixel and the y value for each pixel. i.e. an n x m array: (which way x and y are I am not sure...)## SAH: x = [[ 1 2 3 4 ... n ]    y = [[ 1 1 1 1 ... 1 ]## SAH:      [ 1 2 3 4 ... n ]         [ 2 2 2 2 ... 2 ]## SAH:      ...                       ...## SAH:      [ 1 2 3 4 ... n ]]        [ m m m m ... m ]]## SAH: x and y have to be the same size.###I'm assuming therefore that essentially the 2_theta values are the same for all chi and vice-versa. Is that correct?# I also had to limit the input array to be square i.e. nxn not nxm, is that normal?## SAH: No the arrays can be n x m but I think your dimension of x and y if correct will solve the dimension issues. 